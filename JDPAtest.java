package testconnect;

import com.sun.jdi.Field;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.event.ClassPrepareEvent;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.ModificationWatchpointEvent;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMDisconnectEvent;
import com.sun.jdi.request.ClassPrepareRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.ModificationWatchpointRequest;
import java.io.IOException;
import java.util.List;
import java.util.Scanner;

/**
* The problem with the loading the agent part was that the port was originally set to 5000.
* However, we don't know if that is the correct port so taking it out makes it find one that is
* open and sets it itself. Now, when we build it, it will be successful.
*/
public class JDPAtest {

    /**
* http://download.oracle.com/javase/6/docs/jdk/api/attach/spec/com/sun/tools/attach/VirtualMachine.html
*/
    public static final String CLASS_NAME = "Test";
    public static final String FIELD_NAME = "head";

    public static void main(String[] args) throws IOException, InterruptedException, IncompatibleThreadStateException {


        getFile();

        VirtualMachine vm = new VMAcquirer().connect(8000);

/* Messing around with some of the VirtualMachine methods
* the List at is a copy of "allThreads()" generated by the VM
* Printing out each thread.name() show you obviously the thread
* you're looking at. so we're making progress here.
*
* I don't know how useful doing this with classes will be (if at all) but
* You can do the same thing with allClasses() like this:
* List<ReferenceType> ac = vm.allClasses();
* Notice the two different types ThreadReference and ReferenceType
* (learned all of this from the javadocs and messing around)
*
* the suspend feature we know works because it stops the program
* so that's a nonissue (comment out the vm.resume() line to see)
*/
        List<ThreadReference> at = vm.allThreads();
        vm.suspend();

        for (ThreadReference thread : at) {
            System.out.println("Thread: " + thread.name());
            List<ObjectReference> or =  thread.ownedMonitors();
            for (ObjectReference object : or) {
            	System.out.println("Objects: " + object);
            }
        }

       /* String desc = vm.description();
        String name = vm.name();
        System.out.println("Description of VM: " + desc);
        System.out.println("Name of VM: " + name);
       */
        vm.resume();
        //process events
        EventQueue eventQueue = vm.eventQueue();
        while (true) {
            EventSet eventSet = eventQueue.remove();
            for (Event event : eventSet) {
                if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {
                    // exit
                    return;
                }
                else if (event instanceof ClassPrepareEvent) {
                    // watch field on loaded class
                    ClassPrepareEvent classPrepEvent = (ClassPrepareEvent) event;
                    ReferenceType refType = classPrepEvent.referenceType();
                    addFieldWatch((VirtualMachine) vm, refType);
                }
                else if (event instanceof ModificationWatchpointEvent) {
                    // a Test.foo has changed
                    ModificationWatchpointEvent modEvent = (ModificationWatchpointEvent) event;
                    System.out.println("old=" + modEvent.valueCurrent());
                    System.out.println("new=" + modEvent.valueToBe());
                    System.out.println();
                }
            }
            eventSet.resume();
        }
    }

    private static void addClassWatch(VirtualMachine vm) {
        EventRequestManager erm = vm.eventRequestManager();
        ClassPrepareRequest classPrepareRequest = erm.createClassPrepareRequest();
        classPrepareRequest.addClassFilter(CLASS_NAME);
        classPrepareRequest.setEnabled(true);
    }

    private static void addFieldWatch(VirtualMachine vm,ReferenceType refType) {
        EventRequestManager erm = vm.eventRequestManager();
        Field field = refType.fieldByName(FIELD_NAME);
        ModificationWatchpointRequest modificationWatchpointRequest = erm.createModificationWatchpointRequest(field);
        modificationWatchpointRequest.setEnabled(true);
    }

    public static void getFile() {

        System.out.println("What Java file (a file ending in '.java') would you like to use?");

        /**
         * We ask the user what file they want to use, and run it with all the
         * debug options enabled. This allows us to not have to manually run the
         * program from the terminal every time. However, the Interesting.java
         * (or whatever file) needs to be in the SAME directory as the source right now
         */
        try {
            //read in the file as a string
            Scanner inScanner = new Scanner(System.in);
            String input = inScanner.nextLine();
            System.out.println("You selected: " + input );

            String[] compile = {"xterm", "-e", "javac", input };
            /**
             * getRuntime().exec() is cross platform, but the command we're entering here
             * is NOT. It works in a linux (maybe OS X) environment. Should in theory work
             * as long as you have bash, but there's no way this will work in Windows. We
             * use xterm above because it's not dependent on UI (e.g., GNOME and KDE).
             * xterm should be on any X-based system and is in $PATH so we don't
             * need the absolute path. For some reason, if you put the whole thing in as
             * one command (or two joined by &&) to compile AND run in debug, it doesn't
             * work. Working on that...
             */
            Runtime.getRuntime().exec(compile);
            //Runtime.getRuntime().exec(command);
        }
        catch(Exception e){
            System.out.println("It seems this program crashed. Awesome...");
            System.out.println(e.toString());
        }

    }
}