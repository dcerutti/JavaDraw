import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Field;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.StackFrame;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.VirtualMachine;
import java.io.IOException;
import java.util.List;
import java.util.Scanner;

/**
* The problem with the loading the agent part was that the port was originally set to 5000.
* However, we don't know if that is the correct port so taking it out makes it find one that is
* open and sets it itself. Now, when we build it, it will be successful.
*/
public class JDPAtest {

    /**
* http://download.oracle.com/javase/6/docs/jdk/api/attach/spec/com/sun/tools/attach/VirtualMachine.html
*/
    public static final String CLASS_NAME = "Test";
    public static final String FIELD_NAME = "head";
    public static Node head;


//    public static void main(String[] args) throws IOException, InterruptedException, IncompatibleThreadStateException, AbsentInformationException {
//
//        //getFile();
//        getVM();
//
//    }

    public static void getVM() throws InterruptedException, IncompatibleThreadStateException, IOException {

        VirtualMachine vm = new VMAcquirer().connect(8000);

        /* Messing around with some of the VirtualMachine methods
         * the List at is a copy of "allThreads()" generated by the VM
         * Printing out each thread.name() show you obviously the thread
         * you're looking at. so we're making progress here.
         *
         * I don't know how useful doing this with classes will be (if at all) but
         * You can do the same thing with allClasses() like this:
         * List<ReferenceType> ac = vm.allClasses();
         * Notice the two different types ThreadReference and ReferenceType
         * (learned all of this from the javadocs and messing around)
         *
         * the suspend feature we know works because it stops the program
         * so that's a nonissue (comment out the vm.resume() line to see)
         */
        List<ThreadReference> at = vm.allThreads();
        vm.suspend();
        System.out.println("...Suspended...");
        int i = 0;
        Node top = new Node(NODETYPE.FUNCTION,"Virtual Machine");
        for (ThreadReference thread : at) {
//        	if (i < 3){
//        		i++;
//        		continue;
//        	}
        	Node temp = new Node(NODETYPE.FUNCTION , thread.name());
        	top.children.add(temp);
        	
            System.out.println("Thread: " + thread.name());
            List<StackFrame> sf = thread.frames();
            for (StackFrame frame : sf) {
            	
            	if(frame.thisObject() != null){
            		Node temp2 = new Node(NODETYPE.OBJECT, frame.thisObject().referenceType().name());
                	temp.children.add(temp2);
                	
            	}
            	
            	
            	if (frame.thisObject() == null)
            		continue;
            	List<Field> fields = frame.thisObject().referenceType().fields();
            	for (Field field : fields) {
            		System.out.println("\tObject --- " + frame.thisObject().referenceType().name() + "---  " + field.name() 
            				+ " = " + frame.thisObject().getValue(field));
            	}
            }
        }
        
        head = top;

        /* String desc = vm.description();
        String name = vm.name();
        System.out.println("Description of VM: " + desc);
        System.out.println("Name of VM: " + name);
         */
        System.out.println("...Resuming...");
        vm.resume();
    }
    
    public static Node getHead(){
    	return head;
    }
        

    public static void getFile() {

        System.out.println("What Java file (a file ending in '.java') would you like to use?");

        /**
         * We ask the user what file they want to use, and run it with all the
         * debug options enabled. This allows us to not have to manually run the
         * program from the terminal every time. However, the Interesting.java
         * (or whatever file) needs to be in the SAME directory as the source right now
         */
        try {
            //read in the file as a string
            Scanner inScanner = new Scanner(System.in);
            String input = inScanner.nextLine();
            //this takes the string and chops off the ".java" so we can run the class later
            String className = input.substring(0, (input.length()-5));

            System.out.println("You selected: " + input );
            System.out.println("Creating class:" + className);

            String[] compile = {"xterm", "-e", "javac", input };
            String[] run = {"xterm", "-e", "java", "-Xdebug", "-Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n", className };
            /**
             * getRuntime().exec() is cross platform, but the command we're entering here
             * is NOT. It works in a linux (maybe OS X) environment. Should in theory work
             * as long as you have bash, but there's no way this will work in Windows. We
             * use xterm above because it's not dependent on UI (e.g., GNOME and KDE).
             * xterm should be on any X-based system and is in $PATH so we don't
             * need the absolute path. For some reason, if you put the whole thing in as
             * one command (or two joined by &&) to compile AND run in debug, it doesn't
             * work. Need two .exec() functions.
             */
            Runtime.getRuntime().exec(compile);
            Runtime.getRuntime().exec(run);

            /**
             * We pause the program for 5 seconds (chosen arbitrarily) because if
             * we jump right to the next portion too quickly the program isn't yet
             * listening on the right port. Annoying to figure that one out...
             */
            Thread.sleep(5000);
        }
        catch(Exception e){
            System.out.println("It seems this program crashed. Awesome...");
            System.out.println(e.toString());
        }
    }
}
