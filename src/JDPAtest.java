
import com.sun.jdi.LocalVariable;
import com.sun.jdi.ObjectReference;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Field;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.StackFrame;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.Value;
import com.sun.jdi.VirtualMachine;
import java.io.IOException;
import java.util.List;

/**
 * The problem with the loading the agent part was that the port was originally
 * set to 5000. However, we don't know if that is the correct port so taking it
 * out makes it find one that is open and sets it itself. Now, when we build it,
 * it will be successful.
 */
public class JDPAtest {

    /**
     * http://download.oracle.com/javase/6/docs/jdk/api/attach/spec/com/sun/
     * tools/attach/VirtualMachine.html
     */
    public static final String CLASS_NAME = "Test";
    public static final String FIELD_NAME = "head";
    public static Node head;

    public static void getVM() {
        try {
            VirtualMachine vm = new VMAcquirer().connect(8000);

            /*
             * Messing around with some of the VirtualMachine methods the List at is
             * a copy of "allThreads()" generated by the VM Printing out each
             * thread.name() show you obviously the thread you're looking at. so
             * we're making progress here.
             *
             * I don't know how useful doing this with classes will be (if at all)
             * but You can do the same thing with allClasses() like this:
             * List<ReferenceType> ac = vm.allClasses(); Notice the two different
             * types ThreadReference and ReferenceType (learned all of this from the
             * javadocs and messing around)
             *
             * the suspend feature we know works because it stops the program so
             * that's a nonissue (comment out the vm.resume() line to see)
             */
            List<ThreadReference> at = vm.allThreads();
            vm.suspend();
            System.out.println("...Suspended...");
            int i = 0;
            Node top = new Node(NODETYPE.FUNCTION, "Virtual Machine");
            for (ThreadReference thread : at) {
                if (i < 3) {
                    i++;
                    continue;
                }

                Node functionNode = new Node(NODETYPE.FUNCTION, thread.name());
                top.children.add(functionNode);
                functionNode.type = thread.name();
                functionNode.name = "CallStack";

                System.out.println("Thread: " + thread.name());
                List<StackFrame> sf = thread.frames();
                for (StackFrame frame : sf) {

                    if (frame.thisObject() != null) {
                        // Node temp2 = new Node(NODETYPE.OBJECT,
                        // frame.thisObject().referenceType().name());
                        // temp.children.add(temp2);
                    }
                    List<LocalVariable> lv;

                    try {
                        lv = frame.visibleVariables();
                    } catch (AbsentInformationException aie) {
                        System.err.println("No locals in: " + frame);
                        continue;
                    }

                    for (LocalVariable var : lv) {

                        Value value = frame.getValue(var);
                        System.out.println("\tVar: " + var.typeName() + " "
                                + var.name() + " value =" + value);

                        Node objectNode = new Node(NODETYPE.OBJECT);
                        objectNode.type = var.typeName();
                        objectNode.name = var.name();
                        objectNode.value = idExtract(value);

                        functionNode.children.add(objectNode);

                        varTraverse(value, objectNode, 1);
                        System.out.println();
                    }

                    if (frame.thisObject() == null) {
                        continue;
                    }
                    // List<Field> fields =
                    // frame.thisObject().referenceType().fields();
                    // for (Field field : fields) {
                    // System.out.println("\tObject --- " +
                    // frame.thisObject().referenceType().name() + "--- " +
                    // field.name()
                    // + " = " + frame.thisObject().getValue(field));
                    //
                    // }
                }
            }

            head = top;

            /*
             * String desc = vm.description(); String name = vm.name();
             * System.out.println("Description of VM: " + desc);
             * System.out.println("Name of VM: " + name);
             */
            System.out.println("...Resuming...");
            vm.resume();

        }
        catch (IOException ioe) {
            System.out.println("You tried to do something with a file or VM that doesn't exist. Fix that...");
            System.out.println("Stack Trace: ");
            ioe.getStackTrace();
        }
        catch (IncompatibleThreadStateException ite)
        {
            System.out.println("Thread incompatability problem. Java Debug Interface exception");
            System.out.println("Stack Trace: ");
            ite.getStackTrace();
        }

    }

    public static Node getHead() {
        return head;
    }

    static String idExtract(Value val) {
        String value = "" + val;

        String id = "";
        int indexID = value.indexOf("(id=");
        if (indexID == -1) {
            return value;
        } else {
            id = value.substring(indexID, value.length());
        }

        return id;
    }

    public static void varTraverse(Value value, Node parent, int tab) {
        if (value instanceof ObjectReference) {
            ObjectReference or = (ObjectReference) value;
            List<Field> fields = or.referenceType().fields();
            for (Field field : fields) {
                Value fieldValue = or.getValue(field);

                System.out.println();

                for (int i = 0; i < tab; i++) {
                    System.out.print("\t");
                }



                System.out.print("Value: " + fieldValue + " -" + field.name() + " type- " + field.typeName());
                Node objectNode = new Node(NODETYPE.OBJECT);
                objectNode.type = field.typeName();
                objectNode.name = field.name();
                objectNode.value = idExtract(fieldValue);
                parent.children.add(objectNode);

                varTraverse(fieldValue, objectNode, tab + 1);


            }
        }
    }

    public static void getFile(String n) {

        /**
         * We ask the user what file they want to use, and run it with all the
         * debug options enabled. This allows us to not have to manually run the
         * program from the terminal every time. However, the Interesting.java
         * (or whatever file) needs to be in the SAME directory as the source
         * right now
         */
        try {

            // this takes the string and chops off the ".java" so we can run the
            // class later
            String className = n.substring(0, (n.length() - 5));

            System.out.println("You selected: " + n);
            System.out.println("Creating class:" + className);

            String[] compile = {"xterm", "-e", "javac", "-g", n};
            String[] run = {
                "xterm",
                "-e",
                "java",
                "-Xdebug",
                "-Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n",
                className};
            /**
             * getRuntime().exec() is cross platform, but the command we're
             * entering here is NOT. It works in a linux (maybe OS X)
             * environment. Should in theory work as long as you have bash, but
             * there's no way this will work in Windows. We use xterm above
             * because it's not dependent on UI (e.g., GNOME and KDE). xterm
             * should be on any X-based system and is in $PATH so we don't need
             * the absolute path. For some reason, if you put the whole thing in
             * as one command (or two joined by &&) to compile AND run in debug,
             * it doesn't work. Need two .exec() functions.
             */
            Runtime.getRuntime().exec(compile);
            Runtime.getRuntime().exec(run);

            /**
             * We pause the program for 5 seconds (chosen arbitrarily) because
             * if we jump right to the next portion too quickly the program
             * isn't yet listening on the right port. Annoying to figure that
             * one out...
             */
            Thread.sleep(5000);
        } catch (Exception e) {
            System.out.println("It seems this program crashed. Awesome...");
            System.out.println(e.toString());
        }
    }
}
